import { rpcUrl, networkPassphrase } from "./util";

// Contract ID - will be populated after deployment
// Update this with your deployed contract ID from contract-id.txt
export const CONTRACT_ID = process.env.PUBLIC_LIMIT_ORDER_CONTRACT_ID || "";

// Helper to create contract client
// This will be updated once the limit_order package is generated by stellar scaffold
export const getLimitOrderClient = (publicKey?: string) => {
  // TODO: Uncomment when limit_order package is generated:
  // import * as LimitOrderClient from 'limit_order';
  // return new LimitOrderClient.Client({ networkPassphrase, contractId: CONTRACT_ID, rpcUrl, allowHttp: true, publicKey });

  // Temporary placeholder
  return {
    contractId: CONTRACT_ID,
    rpcUrl,
    networkPassphrase,
    publicKey,
  } as any;
};

// Types matching the contract
export interface Intent {
  id: bigint;
  creator: string;
  sell_token: string;
  sell_amount: bigint;
  buy_token: string;
  min_buy_amount: bigint;
  target_price: bigint;
  incentive: bigint;
  expiry: bigint;
  status: IntentStatus;
  executor?: string;
  actual_buy_amount?: bigint;
}

export enum IntentStatus {
  Active = "Active",
  Executed = "Executed",
  Cancelled = "Cancelled",
  Expired = "Expired",
}

export interface Balance {
  available: bigint;
  locked: bigint;
}

// Price scale constant from contract
export const PRICE_SCALE = 10_000_000n;

// Common testnet tokens
// These are Soroban token contract addresses on Stellar Testnet
export const TESTNET_TOKENS = {
  // Native XLM wrapped as Soroban token
  XLM: "CDLZFC3SYJYDZT7K67VZ75HPJVIEUVNIXF47ZG2FB2RMQQVU2HHGCYSC",

  // USDC testnet token
  USDC: "CBBHRKEP5M3NUDRISGLJKGHDHX3DA2CN2AZBQY6WLVUJ7VNLGSKBDUCM",

  // AQUA token
  AQUA: "GBNZILSTVQZ4R7IKQDGHYGY2QXL5QOFJYQMXPKWRRM5PAV7Y4M67AQUA",
};

// Mainnet tokens (for production)
export const MAINNET_TOKENS = {
  // Native XLM
  XLM: "CAS3J7GYLGXMF6TDJBBYYSE3HQ6BBSMLNUQ34T6TZMYMW2EVH34XOWMA",

  // USDC on mainnet
  USDC: "CCW67TSZV3SSS2HXMBQ5JFGCKJNXKZM7UQUWUZPUTHXSTZLEO7SJMI75",

  // AQUA on mainnet
  AQUA: "CAQCFVLOBK5GIULPNZRGATJJMIZL5BSP7X5YJVMGCPTUEPFM4AVSRCJU",
};

// You can add any Soroban token by its contract address
// To find token addresses:
// 1. Testnet: https://stellar.expert/explorer/testnet
// 2. Mainnet: https://stellar.expert/explorer/public
// 3. Or use Stellar CLI: stellar contract id asset --asset <ASSET_CODE:ISSUER>

// Example: How to add a custom token
export const addCustomToken = (symbol: string, contractAddress: string) => {
  return {
    symbol,
    address: contractAddress,
  };
};

// For external assets (not on Stellar), the oracle uses symbols
// These are queried as Asset::Other(Symbol) in the contract
export const ORACLE_SYMBOLS = {
  BTC: "BTC",
  ETH: "ETH",
  USD: "USD",
  EUR: "EUR",
  // Add more as supported by Reflector Oracle
};

// Helper functions to format values
export const formatTokenAmount = (
  amount: bigint,
  decimals: number = 7,
): string => {
  const divisor = BigInt(10 ** decimals);
  const whole = amount / divisor;
  const fraction = amount % divisor;
  const fractionStr = fraction.toString().padStart(decimals, "0");
  return `${whole}.${fractionStr}`;
};

export const parseTokenAmount = (
  amount: string,
  decimals: number = 7,
): bigint => {
  const parts = amount.split(".");
  const whole = BigInt(parts[0] || "0");
  const fraction = parts[1] || "0";
  const fractionPadded = fraction.padEnd(decimals, "0").slice(0, decimals);
  return whole * BigInt(10 ** decimals) + BigInt(fractionPadded);
};

export const formatPrice = (price: bigint): string => {
  return formatTokenAmount(price, 7);
};

export const parsePrice = (price: string): bigint => {
  return parseTokenAmount(price, 7);
};

// Helper to check if contract is configured
export const isContractConfigured = (): boolean => {
  return CONTRACT_ID !== "";
};
