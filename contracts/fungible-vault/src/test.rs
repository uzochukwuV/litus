#![cfg(test)]

extern crate std;

use soroban_sdk::{contract, contractimpl, testutils::Address as _, Address, Env, String};
use stellar_macros::default_impl;
use stellar_tokens::fungible::{Base, FungibleToken};

use crate::contract::{ExampleContract, ExampleContractClient};

// Mock Asset Contract - Simple fungible token to use as underlying asset
#[contract]
pub struct MockAssetContract;

#[contractimpl]
impl MockAssetContract {
    pub fn __constructor(e: &Env, initial_supply: i128, admin: Address) {
        Base::set_metadata(
            e,
            18,
            String::from_str(e, "Mock Asset Token"),
            String::from_str(e, "MAT"),
        );
        Base::mint(e, &admin, initial_supply);
    }
}

#[default_impl]
#[contractimpl]
impl FungibleToken for MockAssetContract {
    type ContractType = stellar_tokens::fungible::Base;
}

// Client for the mock asset contract is automatically generated by the
// #[contract] macro

fn create_vault_client<'a>(
    e: &Env,
    asset_address: &Address,
    decimals_offset: u32,
) -> ExampleContractClient<'a> {
    let vault_address = e.register(ExampleContract, (asset_address, decimals_offset));
    ExampleContractClient::new(e, &vault_address)
}

fn create_asset_client<'a>(
    e: &Env,
    initial_supply: i128,
    admin: &Address,
) -> MockAssetContractClient<'a> {
    let asset_address = e.register(MockAssetContract, (initial_supply, admin));
    MockAssetContractClient::new(e, &asset_address)
}

#[test]
fn test_vault_initialization() {
    let e = Env::default();
    let admin = Address::generate(&e);
    let initial_supply = 1_000_000_000_000_000_000i128; // 1M tokens with 18 decimals
    let decimals_offset = 6;

    // Create asset contract
    let asset_client = create_asset_client(&e, initial_supply, &admin);
    let asset_address = asset_client.address.clone();

    // Create vault contract
    let vault_client = create_vault_client(&e, &asset_address, decimals_offset);

    // Test vault initialization
    assert_eq!(vault_client.query_asset(), asset_address);
    assert_eq!(vault_client.decimals(), 18 + decimals_offset); // asset decimals + offset
    assert_eq!(vault_client.total_supply(), 0);
    assert_eq!(vault_client.total_assets(), 0);
}

#[test]
fn test_vault_deposit() {
    let e = Env::default();
    let admin = Address::generate(&e);
    let user = Address::generate(&e);
    let initial_supply = 1_000_000_000_000_000_000i128;
    let decimals_offset = 6;
    let deposit_amount = 100_000_000_000_000_000i128; // 100 tokens

    // Create asset contract
    let asset_client = create_asset_client(&e, initial_supply, &admin);
    let asset_address = asset_client.address.clone();

    // Create vault contract
    let vault_client = create_vault_client(&e, &asset_address, decimals_offset);

    e.mock_all_auths();

    // Transfer some assets to user for testing
    asset_client.transfer(&admin, &user, &deposit_amount);
    assert_eq!(asset_client.balance(&user), deposit_amount);

    // User deposits assets into vault
    let shares_minted = vault_client.deposit(&deposit_amount, &user, &user, &user);

    // Check balances
    assert_eq!(vault_client.balance(&user), shares_minted);
    assert_eq!(vault_client.total_supply(), shares_minted);
    assert_eq!(vault_client.total_assets(), deposit_amount);
    assert_eq!(asset_client.balance(&user), 0);
    assert_eq!(asset_client.balance(&vault_client.address), deposit_amount);

    // For first deposit, shares should equal assets (1:1 ratio initially)
    assert_eq!(shares_minted, deposit_amount * 10i128.pow(decimals_offset));
}

#[test]
fn test_vault_mint() {
    let e = Env::default();
    let admin = Address::generate(&e);
    let user = Address::generate(&e);
    let initial_supply = 1_000_000_000_000_000_000i128;
    let decimals_offset = 6;
    let shares_to_mint = 100_000_000_000_000_000i128;

    // Create asset contract
    let asset_client = create_asset_client(&e, initial_supply, &admin);
    let asset_address = asset_client.address.clone();

    // Create vault contract
    let vault_client = create_vault_client(&e, &asset_address, decimals_offset);

    e.mock_all_auths();

    // Transfer assets to user
    let required_assets = vault_client.preview_mint(&shares_to_mint);
    asset_client.transfer(&admin, &user, &required_assets);

    // User mints specific amount of shares
    let assets_deposited = vault_client.mint(&shares_to_mint, &user, &user, &user);

    // Check balances
    assert_eq!(vault_client.balance(&user), shares_to_mint);
    assert_eq!(vault_client.total_supply(), shares_to_mint);
    assert_eq!(vault_client.total_assets(), assets_deposited);
    assert_eq!(assets_deposited, required_assets);
}

#[test]
fn test_vault_withdraw() {
    let e = Env::default();
    let admin = Address::generate(&e);
    let user = Address::generate(&e);
    let initial_supply = 1_000_000_000_000_000_000i128;
    let decimals_offset = 6;
    let deposit_amount = 100_000_000_000_000_000i128;
    let withdraw_amount = 50_000_000_000_000_000i128; // Withdraw half

    // Create contracts
    let asset_client = create_asset_client(&e, initial_supply, &admin);
    let asset_address = asset_client.address.clone();
    let vault_client = create_vault_client(&e, &asset_address, decimals_offset);

    e.mock_all_auths();

    // Setup: deposit assets first
    asset_client.transfer(&admin, &user, &deposit_amount);
    let shares_minted = vault_client.deposit(&deposit_amount, &user, &user, &user);

    // Withdraw assets
    let shares_burned = vault_client.withdraw(&withdraw_amount, &user, &user, &user);

    // Check balances
    assert_eq!(vault_client.balance(&user), shares_minted - shares_burned);
    assert_eq!(vault_client.total_assets(), deposit_amount - withdraw_amount);
    assert_eq!(asset_client.balance(&user), withdraw_amount);
}

#[test]
fn test_vault_redeem() {
    let e = Env::default();
    let admin = Address::generate(&e);
    let user = Address::generate(&e);
    let initial_supply = 1_000_000_000_000_000_000i128;
    let decimals_offset = 6;
    let deposit_amount = 100_000_000_000_000_000i128;

    // Create contracts
    let asset_client = create_asset_client(&e, initial_supply, &admin);
    let asset_address = asset_client.address.clone();
    let vault_client = create_vault_client(&e, &asset_address, decimals_offset);

    e.mock_all_auths();

    // Setup: deposit assets first
    asset_client.transfer(&admin, &user, &deposit_amount);
    let shares_minted = vault_client.deposit(&deposit_amount, &user, &user, &user);

    // Redeem half the shares
    let shares_to_redeem = shares_minted / 2;
    let assets_received = vault_client.redeem(&shares_to_redeem, &user, &user, &user);

    // Check balances
    assert_eq!(vault_client.balance(&user), shares_minted - shares_to_redeem);
    assert_eq!(vault_client.total_supply(), shares_minted - shares_to_redeem);
    assert_eq!(asset_client.balance(&user), assets_received);

    // Should receive approximately half the original deposit
    let expected_assets = deposit_amount / 2;
    assert!(assets_received >= expected_assets - 1 && assets_received <= expected_assets + 1);
}

#[test]
fn test_conversion_functions() {
    let e = Env::default();
    let admin = Address::generate(&e);
    let user = Address::generate(&e);
    let initial_supply = 1_000_000_000_000_000_000i128;
    let decimals_offset = 6;
    let deposit_amount = 100_000_000_000_000_000i128;

    // Create contracts
    let asset_client = create_asset_client(&e, initial_supply, &admin);
    let asset_address = asset_client.address.clone();
    let vault_client = create_vault_client(&e, &asset_address, decimals_offset);

    e.mock_all_auths();

    // Test conversions with empty vault (should be 1:1 with offset)
    let assets = 1_000_000_000_000_000_000i128; // 1 token
    let expected_shares = assets * 10i128.pow(decimals_offset);

    assert_eq!(vault_client.convert_to_shares(&assets), expected_shares);
    assert_eq!(vault_client.convert_to_assets(&expected_shares), assets);

    // Test preview functions
    assert_eq!(vault_client.preview_deposit(&assets), expected_shares);
    assert_eq!(vault_client.preview_mint(&expected_shares), assets);
    assert_eq!(vault_client.preview_withdraw(&assets), expected_shares);
    assert_eq!(vault_client.preview_redeem(&expected_shares), assets);

    // Add some assets to vault and test conversions
    asset_client.transfer(&admin, &user, &deposit_amount);
    vault_client.deposit(&deposit_amount, &user, &user, &user);

    // Test conversions with vault having assets
    let new_assets = 50_000_000_000_000_000i128;
    let shares = vault_client.convert_to_shares(&new_assets);
    let converted_back = vault_client.convert_to_assets(&shares);

    // Should be approximately equal (allowing for rounding)
    assert!(converted_back >= new_assets - 1 && converted_back <= new_assets + 1);
}

#[test]
fn test_max_functions() {
    let e = Env::default();
    let admin = Address::generate(&e);
    let user = Address::generate(&e);
    let initial_supply = 1_000_000_000_000_000_000i128;
    let decimals_offset = 6;
    let deposit_amount = 100_000_000_000_000_000i128;

    // Create contracts
    let asset_client = create_asset_client(&e, initial_supply, &admin);
    let asset_address = asset_client.address.clone();
    let vault_client = create_vault_client(&e, &asset_address, decimals_offset);

    e.mock_all_auths();

    // Test max functions with empty vault
    assert_eq!(vault_client.max_deposit(&user), i128::MAX);
    assert_eq!(vault_client.max_mint(&user), i128::MAX);
    assert_eq!(vault_client.max_withdraw(&user), 0); // No shares yet
    assert_eq!(vault_client.max_redeem(&user), 0); // No shares yet

    // Deposit some assets
    asset_client.transfer(&admin, &user, &deposit_amount);
    let shares_minted = vault_client.deposit(&deposit_amount, &user, &user, &user);

    // Test max functions with user having shares
    assert_eq!(vault_client.max_redeem(&user), shares_minted);
    let max_withdraw = vault_client.max_withdraw(&user);
    assert!(max_withdraw > 0);
    assert!(max_withdraw <= deposit_amount);
}

#[test]
fn test_multiple_users_deposit_withdraw() {
    let e = Env::default();
    let admin = Address::generate(&e);
    let user1 = Address::generate(&e);
    let user2 = Address::generate(&e);
    let initial_supply = 1_000_000_000_000_000_000i128;
    let decimals_offset = 6;
    let deposit_amount = 100_000_000_000_000_000i128;

    // Create contracts
    let asset_client = create_asset_client(&e, initial_supply, &admin);
    let asset_address = asset_client.address.clone();
    let vault_client = create_vault_client(&e, &asset_address, decimals_offset);

    e.mock_all_auths();

    // Give assets to both users
    asset_client.transfer(&admin, &user1, &deposit_amount);
    asset_client.transfer(&admin, &user2, &deposit_amount);

    // User1 deposits first
    let shares1 = vault_client.deposit(&deposit_amount, &user1, &user1, &user1);

    // User2 deposits same amount (should get same shares since ratio is still 1:1)
    let shares2 = vault_client.deposit(&deposit_amount, &user2, &user2, &user2);

    assert_eq!(shares1, shares2);
    assert_eq!(vault_client.total_supply(), shares1 + shares2);
    assert_eq!(vault_client.total_assets(), deposit_amount * 2);

    // User1 withdraws half their assets
    let withdraw_amount = deposit_amount / 2;
    let shares_burned = vault_client.withdraw(&withdraw_amount, &user1, &user1, &user1);

    assert_eq!(vault_client.balance(&user1), shares1 - shares_burned);
    assert_eq!(vault_client.balance(&user2), shares2);
    assert_eq!(asset_client.balance(&user1), withdraw_amount);
}

#[test]
fn test_deposit_max_validation() {
    let e = Env::default();
    let admin = Address::generate(&e);
    let user = Address::generate(&e);
    let initial_supply = 1_000_000_000_000_000_000i128;
    let decimals_offset = 6;

    // Create contracts
    let asset_client = create_asset_client(&e, initial_supply, &admin);
    let asset_address = asset_client.address.clone();
    let vault_client = create_vault_client(&e, &asset_address, decimals_offset);

    e.mock_all_auths();

    // Test that max_deposit returns i128::MAX
    let max_deposit = vault_client.max_deposit(&user);
    assert_eq!(max_deposit, i128::MAX);

    // Test normal deposit works fine
    let deposit_amount = 100_000_000_000_000_000i128;
    asset_client.transfer(&admin, &user, &deposit_amount);
    let shares = vault_client.deposit(&deposit_amount, &user, &user, &user);
    assert!(shares > 0);
}

#[test]
#[should_panic(expected = "Error(Contract, #407)")]
fn test_withdraw_exceeds_max() {
    let e = Env::default();
    let admin = Address::generate(&e);
    let user = Address::generate(&e);
    let initial_supply = 1_000_000_000_000_000_000i128;
    let decimals_offset = 6;
    let deposit_amount = 100_000_000_000_000_000i128;

    // Create contracts
    let asset_client = create_asset_client(&e, initial_supply, &admin);
    let asset_address = asset_client.address.clone();
    let vault_client = create_vault_client(&e, &asset_address, decimals_offset);

    e.mock_all_auths();

    // Deposit some assets
    asset_client.transfer(&admin, &user, &deposit_amount);
    vault_client.deposit(&deposit_amount, &user, &user, &user);

    // Try to withdraw more than max
    let max_withdraw = vault_client.max_withdraw(&user);
    vault_client.withdraw(&(max_withdraw + 1), &user, &user, &user);
}

#[test]
#[should_panic(expected = "Error(Contract, #408)")]
fn test_redeem_exceeds_max() {
    let e = Env::default();
    let admin = Address::generate(&e);
    let user = Address::generate(&e);
    let initial_supply = 1_000_000_000_000_000_000i128;
    let decimals_offset = 6;
    let deposit_amount = 100_000_000_000_000_000i128;

    // Create contracts
    let asset_client = create_asset_client(&e, initial_supply, &admin);
    let asset_address = asset_client.address.clone();
    let vault_client = create_vault_client(&e, &asset_address, decimals_offset);

    e.mock_all_auths();

    // Deposit some assets
    asset_client.transfer(&admin, &user, &deposit_amount);
    let shares = vault_client.deposit(&deposit_amount, &user, &user, &user);

    // Try to redeem more shares than user has
    vault_client.redeem(&(shares + 1), &user, &user, &user);
}
